# Как работать с Гитом

### Основные положения

* Есть две постоянные ветки: `develop` и `master`

* В ветку `develop` нельзя коммитить

* На каждый таск создается отдельная ветка от ветки `develop`, которая именуется `feature/JIRA-TASK-ID_Task_description` (например `feature/LOL-131_Add_welcome_screen`)

* Вся работа по таску ведется в этой ветке

* Изменения из `develop` стягиваются в эту ветку как можно чаще

* На каждый крупный баг также создается отдельная ветка (`fix/JIRA-TASK-ID_Bug_description`), работать с ним следует так же, как с таском

* Мелкие баги можно фиксить в одной ветке (`fix/Bugs_description`, например `fix/profile_screen_crashes`)

* После отправки такой ветки на ревью фиксить в ней новые баги не разрешается

* Когда таск готов, производится `pull request` в ветку `develop`.

* После прохождения code review ветка мержится в `develop` и затем удаляется

* Pull request отдается кому-нибудь (знающему технологию) для code review

* Для тестирования собирается билд из ветки `develop`.

* Как только в ветке `develop` накопилось достаточно фич для релиза делается пул из `develop` в `master`. Такой пул запускает статический анализ

* После прохождения статического анализа и code review собирается билд для показа заказчику (из пула). Этот билд тоже тестируется

* После того, как был сделан пул-реквест из `develop` в `master` запрещается изменять ветку `develop` (запрещается добавлять новые фичи, но разрешается исправлять найденые баги), пока пул не будет замерджен, либо закрыт

* Как только заказчик одобрил сборку, пул-реквест мерджится в `master`.

* Тестировщик собирает версию из мастера и тестирует перед релизом

* Релизится версия, которая находится в мастере

* Ветка `master` должна отражать состояние приложения, которое выложено в store. (если приложение еще не выкладывалось, в мастере должен быть код приложения, отданного заказчику)

* Если наден баг в сборке из открытого пул-реквеста, то создается бранч `fix/*` от ветки `develop`. После исправления делается пул-реквест в ветку `develop`

* Если найден баг в ветке мастер и его нужно срочно починить и перевыложить приложение, то создается бранч `hotfix/*` от ветки мастер и после фикса делается пул-реквест в ветку `master`. Ветку `hotfix/*` допускается мерджить с веткой `develop`

* **Запрещается пушить изменения в ветку после получения аппрува. В противном случае pull request должен снова пройти ревью.**



![1](http://cs629123.vk.me/v629123979/3a451/2U9-txzsgfQ.jpg)

### Оформление комментария к коммиту

Коммиты делятся на две категории: коммит по таске/фиксу/прочему, что имеет идентификатор JIRA-TASK-ID, далее идентифицирумый коммит, и неидентифицируемый коммит, который такого идентификатора не имеет. Примеры неидентифицируемых коммитов: фиксы по PR (пул-реквест), хотфиксы, рефакторинг и т.п.

* Формат сообщений индентифицируемых коммитов:

`LOL-XXXX` `[Add|Remove|Edit|Fix|Configure|...]` `<описание выполненного действия подробнее>`

где:   
`LOL-XXXX` - номер таски;   
`[Add|Remove|Edit|Fix|Configure|...]` - указание основного действия в коммите с большой буквы. Это делает для того, чтобы бегло понимать что было добавлено или удалено, или исправлено;   
`<описание выполненного действия подробнее>` - продолжение описания указанного действия с маленькой буквы.
   
Все части являются обязательными. Пример оформления виден на картинке выше.

* Формат сообщений неиндентифицируемых коммитов:

`[Add|Remove|Edit|Fix|Configure|...]` `<описание выполненного действия подробнее>`

Частым примером не идентифицируемого коммита является внесение правок по код-ревью из PR. Пример оформления такого коммита:

Fix PR issues `{from <Имя того, кто оставил замечения>}`

где:   
`{from <Имя того, кто оставил замечения>}` - не обязательная часть. Нужна она для того, чтобы указать чьи конкретно замечания были учтены. Пример "Fix PR issues from viveron", если в текущем коммите исправлены замечания, указанные пользователем под ником viveron.

### Работа с двумя "мастер-ветками"

Если возникает ситуация поддержки двух версий приложения, например в ветке `master` лежит старое приложение и для него не создаются новые фичи, а только исправляются баги. И мы хотим начать разрабатывать новое приложение, которое в дальнейшем заменит старое. В таком случае старое приложение переезжает из ветки `master` в ветку `legacy`, разработка нового ведется в ветке `master` по стандартному сценарию. Разработка старого ведется в ветке `legacy` и считается мастером для старого приложения.

### Несколько релизов

Если в ветке `develop` накопилось определенное количество фичей, пара из которых не должна попасть в текущий релиз (заказчик передумал), тогда создается ветка `release/*` для текущего релиза и туда перемещаются нужные фичи

### Работа с сабмодулями

* Сабмодули подлючаются **только** через SSH (например, `git@github.com:TouchInstinct/PartiyaEdi-common.git`). Для того чтобы это работало необходимо настроить SSH на Github ([подробнее](https://help.github.com/articles/connecting-to-github-with-ssh/))
* Ревью пулл-реквестов в *common* сабмодули осуществляют разработчики "противоположной" платформы (для iOS - Android, и наоборот)

### Как не больно мержить в мастер из девелопа

1) Чтобы избавиться от конфликтов при мерже дева в мастер, нужно смержить мастер в дев. **Без сквоша!** Иначе, все бесполезно.
2) При мерже девелопа в мастер нужно делать обычный мерж **без сквоша**. Если делать со сквошом, то у тебя изменения будут накапливаться. Если после сквоша еще раз сделать пулл, то снова 100к строк изменений. Если выполнять этот пункт, то отпадет необходимость в первом шаге.
3) Если захочется после удачного мержа в мастер замержить мастер в дев, то не нужно. Все и так будет хорошо.
4) Если были hotfix-пулы в мастер, то не забудьте **обновить девелоп**. Иначе боль будет невыносимая.
